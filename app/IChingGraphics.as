package app {	import flash.display.Sprite;	import flash.display.MovieClip;	import flash.text.TextField;		public class IChingGraphics extends Sprite {				private var _lineWidth:uint;        private var _color:uint = 0xFFFFFF;//default color is white             public var yin:Sprite = new Sprite();        public var yang:Sprite = new Sprite();		public var IC64Hex:Array = new Array("111111","000000","010001","100010","010111","111010","000010","010000","110111","111011","000111","111000","111101","101111","000100","001100","011001","100110","000011","110000","101001","100101","100000","000001","111001","100111","100001","011110","010010","101101","011100","001110","111100","001111","101000","000101","110101","101011","010100","001010","100011","110001","011111","111110","011000","000110","011010","010110","011101","101110","001001","100100","110100","001011","001101","101100","110110","011011","110010","010011","110011","001100","010101","101010");		public function IChingGraphics():void {			// constructor code		}				public function castALine():uint {			return (Math.round(Math.random()) ) + (Math.round(Math.random()) ) + (Math.round(Math.random()) );		}				public function cast(numOfLines:uint = 6):Object {			var gram:Object = new Object();						gram.oldGram = new Object();			gram.oldGram.ID = new uint();			gram.oldGram.binary = new String();			gram.oldGram.graph = new Sprite();						gram.newGram = new Object();			gram.newGram.ID = new uint();			gram.newGram.binary = new String();			gram.newGram.graph = new Sprite();			gram.movingLines = new Object();			gram.movingLines.pos = new Array();			gram.displayResult = new MovieClip();			gram.displayResult.x = 40;			gram.displayResult.y = 50;						_lineWidth=80;			_color= 0xEAEAAE;						for (var i:uint; i<6; i++) {				var line:uint = castALine();								if (line == 1) {					gram.oldGram.binary += "0";					gram.newGram.binary += "0";							} else if (line == 2) {					gram.oldGram.binary += "1";					gram.newGram.binary += "1";									} else if (line == 0) {					var varName3:String = i.toString();					gram.oldGram.binary += "0";								gram.newGram.binary += "1";					gram.movingLines.pos.push(i+1);									} else if (line == 3) {					gram.oldGram.binary += "1";					gram.newGram.binary += "0";					gram.movingLines.pos.push(i+1);				}			}			//assign ID to oldGram			for (var k:uint =0; k <IC64Hex.length; k++) {				if (gram.oldGram.binary == IC64Hex[k].toString()) {					gram.oldGram.ID = k+1;					break;				}			}						//assign ID to newGram			for (var l:uint =0; l <IC64Hex.length; l++) {				if (gram.newGram.binary == IC64Hex[l].toString()) {					gram.newGram.ID = l+1;					break;				}			}			gram.oldGram.data = new XMLList();			gram.oldGram.data= IChingGame.ICData..HEX.(@id=="1");//@id == gram.oldGram.ID						gram.oldGram.image = new String(gram.oldGram.data.IMAGE.toString());			gram.oldGram.judgement = new String(gram.oldGram.data.JUDGEMENT.toString());						if (gram.oldGram.ID != gram.newGram.ID) {//no movingLine														}															gram.oldGram.graph = squareSymbol(drawSymbol(gram.oldGram.binary));			gram.oldGram.graph.name = "oldGram";			gram.displayResult.addChild(gram.oldGram.graph)						if (gram.movingLines.pos.length == 0) {				gram.oldGram.graph.x = 117; //360/2 - _lineWidth/2;			} else {				//Old hexagram				gram.oldGram.graph.x = 15;								//Load new hexagram data														gram.newGram.data = new XMLList();				gram.newGram.data= IChingGame.ICData..HEX.(@id=="2");//@id == gram.newGram.ID							gram.newGram.image = new String(gram.newGram.data.IMAGE.toString());				gram.newGram.judgement = new String(gram.newGram.data.JUDGEMENT.toString());								//New hexagram				gram.newGram.graph = squareSymbol(drawSymbol(gram.newGram.binary));				gram.newGram.graph.name = "newGram";								gram.newGram.graph.x = 360 - _lineWidth - 70;				gram.displayResult.addChild(gram.newGram.graph)								//Moving Lines				gram.movingLines.data = gram.newGram.data.MOVING_LINE;				gram.movingLines.display = new Sprite();				gram.movingLines.display.name = "movingLines_Display";								for (var j:uint=0 ; j < gram.movingLines.pos.length; j++) {					var a:Sprite = drawArrow(_lineWidth, 0x8C7853);					a.y = _lineWidth/5*(gram.movingLines.pos[j]);										if(gram.movingLines.pos[j] == 1) {a.name = "top";} 									else if (gram.movingLines.pos[j] == 2) {a.name = "fifth";}					else if (gram.movingLines.pos[j] == 3) {a.name = "fourth"; }					else if (gram.movingLines.pos[j] == 4) {a.name = "third"; }					else if (gram.movingLines.pos[j] == 5) {a.name = "second";}					else if (gram.movingLines.pos[j] == 6) {a.name = "bottom";}										//trace(gram.movingLines.pos[j]);					gram.movingLines.display.addChild(a);							//gram.movingLines.line[a.name] = gram.newGram.data.MOVING_LINE.getChildAt(j).toString();				}								gram.movingLines.display.x = 115;				gram.movingLines.display.y = -20;// ?				gram.displayResult.addChild(gram.movingLines.display);			}						return gram;		}				public function drawDecorLine(w:uint = 100, h:uint = 10, numOfLines:uint = 3):Sprite {			var decorLine:Sprite = new Sprite();			_lineWidth = h;			//decorLine.addChild(drawRandom(numOfLines));			for (var i:uint = 0; i< w/(h+h/4); i++) {				var s:Sprite = drawRandom(numOfLines);				s.x = (h+h/4)*i;				decorLine.addChild(s);			}						return decorLine;		}				//Draw the Yang line with height = 1/5 width,        public function drawYang():Sprite {            var h:uint;            h =  _lineWidth/5;            return drawRect(_lineWidth,h,0,0);        }               //Draw the Yin line with height = 1/5 width        public function drawYin():Sprite {            var yn:Sprite = new Sprite();            var h:uint; var w:uint; var x:uint;            h = _lineWidth/5;            w = h*2;            x = h*3;            yn.addChild( drawRect(w, h, 0, 0) );            yn.addChild( drawRect(w, h, x, 0) );            return yn;        }                      //Draw iChing Sympol from a String of 0 and 1           public function drawSymbol(sym:String = "10"):Sprite {            var symbol:Sprite = new Sprite;            var line:Sprite = new Sprite;            var i:uint;            for (i = 0; i < sym.length; i++) {                line = null;                if (sym.charAt(i) == "1") {                    line = drawYang();                    line.y = _lineWidth/5*i*2;                                       } else if (sym.charAt(i) == "0") {                    line = drawYin();                    line.y = _lineWidth/5*i*2;                }                 symbol.addChild(line);                           }                       return symbol;                   }               //Draw random iChing symbol        public function drawRandom(numOfLines:uint = 1):Sprite {            var symbol:Sprite = new Sprite;            var line:Sprite = new Sprite;            var rnum:Number = new Number;            var i:uint;            for (i = 0; i < numOfLines; i++) {                rnum = Math.round(Math.random());                line = null;                               if (rnum == 0) {                    line = drawYin();                    line.x = 0;                    line.y = _lineWidth/5*2*i;                } else if (rnum == 1) {                    line = drawYang();                    line.x = 0;                    line.y = _lineWidth/5*2*i;                }                 symbol.addChild(line);            }                               return symbol;        }               //Scale a Sprite        public function scale(obj:Sprite, proportion:int):Sprite {            obj.width = obj.width*proportion;            obj.height = obj.height*proportion;            return obj;        }               //make any I-Ching Symbol square        public function squareSymbol(sym:Sprite):Sprite {            sym.height = sym.width;            return sym;        }       // PRIVATE FUNCTIONS        //draw a rectangle: Return a Sprite           private function drawRect(w:uint, h:uint, x:uint = 0, y:uint = 0, alpha:uint = 1): Sprite {            var rect:Sprite = new Sprite;            //var h:uint;            rect.graphics.beginFill(_color);            rect.graphics.drawRect(0,0,w,h);            rect.graphics.endFill();            rect.x = x;            rect.y = y;            rect.alpha = alpha;            return rect;        }				public function drawArrow(w:uint = 10, color:uint = 0xffffff, alpha:uint = 1):Sprite {			var arw:Sprite = new Sprite();						arw.graphics.beginFill(color);			//A			//arw.graphics.moveTo(w/10*7, 0);			arw.graphics.moveTo(w/10*8.5, 0);						//B            //arw.graphics.lineTo(w, w/10 + w/20);			arw.graphics.lineTo(w, w/20);			//C			//arw.graphics.lineTo(w/10*7,w/10*3);			arw.graphics.lineTo(w/10*8.5, w/10);			//D			//arw.graphics.lineTo(w/10*7,w/10*2);			arw.graphics.lineTo(w/10*9, w/10*2/3);			//E			//arw.graphics.lineTo(0,w/10*2);			arw.graphics.lineTo(0,w/10*2/3);			//F			//arw.graphics.lineTo(0,w/10);			arw.graphics.lineTo(0,w/10*1/3);			//G			//arw.graphics.lineTo(w/10*7, w/10);			arw.graphics.lineTo(w/10*9, w/10*1/3);			//A again			arw.graphics.lineTo(w/10*8.5, 0);            arw.graphics.endFill();						return arw;		}                   //Functions to SET and GET private properties               public function get lineWidth ():uint {            return _lineWidth;        }               public function set lineWidth(v:uint):void {            _lineWidth = v;        }               public function get color():uint {            return _color;        }               public function set color(v:uint):void {            _color = v;        }	}	}